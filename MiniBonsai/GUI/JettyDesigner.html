<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Jetty Transport Hub Designer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c3e50;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .header h1 { font-size: 18px; margin: 0; }
        .header p { font-size: 11px; opacity: 0.9; margin: 2px 0 0 0; }

        /* Workspace */
        .workspace {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            flex: 1;
            overflow: hidden;
        }

        /* Panels */
        .left-panel, .right-panel {
            background: #ecf0f1;
            padding: 15px;
            overflow-y: auto;
        }

        .panel-section {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .panel-section h3 {
            font-size: 13px;
            margin: 0 0 10px 0;
            color: #2c3e50;
            padding-bottom: 8px;
            border-bottom: 2px solid #3498db;
        }

        .form-group { margin-bottom: 10px; }
        .form-label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            color: #34495e;
            margin-bottom: 4px;
        }
        .form-input, .form-select {
            width: 100%;
            padding: 6px 8px;
            border: 2px solid #bdc3c7;
            border-radius: 4px;
            font-size: 12px;
        }
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #3498db;
        }

        .btn {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary { background: linear-gradient(135deg, #3498db, #2980b9); color: white; }
        .btn-success { background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; margin-top: 8px; }
        .btn-warning { background: linear-gradient(135deg, #f39c12, #e67e22); color: white; margin-top: 8px; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }

        .metric {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            margin: 4px 0;
        }
        .metric-label { color: #7f8c8d; }
        .metric-value { font-weight: 600; color: #2c3e50; }

        /* Canvas Area */
        .canvas-area {
            background: #34495e;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            background: white;
            cursor: crosshair;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }

        .canvas-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 100;
        }
        .canvas-controls h4 {
            font-size: 11px;
            margin: 0 0 8px 0;
            color: #2c3e50;
            font-weight: 600;
        }
        .zoom-btn {
            width: 30px;
            height: 30px;
            margin: 2px;
            border: 1px solid #bdc3c7;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .zoom-btn:hover { background: #ecf0f1; }

        .tool-btn {
            padding: 6px 12px;
            margin: 2px;
            border: 2px solid #bdc3c7;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .tool-btn.active {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }
        .tool-btn:hover { border-color: #3498db; }

        /* Footer */
        .footer {
            background: #2c3e50;
            color: white;
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div>
                <h1>üö¢ Jetty Transport Hub Designer</h1>
                <p>Minimalist configurator for ferry terminal layouts</p>
            </div>
            <div style="text-align: right;">
                <h2 style="font-size: 14px; margin: 0;">Ferry Terminal Complex</h2>
                <p id="projectName">Terminal 1 - Jetty Hub</p>
            </div>
        </div>

        <!-- Workspace -->
        <div class="workspace">
            <!-- Left Panel: Parameters -->
            <div class="left-panel">
                <div class="panel-section">
                    <h3>üìè Building Dimensions</h3>
                    <div class="form-group">
                        <label class="form-label">Width (m)</label>
                        <input type="number" class="form-input" id="inputWidth" value="45" min="20" max="100" step="5">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Depth (m)</label>
                        <input type="number" class="form-input" id="inputDepth" value="66" min="20" max="150" step="5">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Number of Floors</label>
                        <input type="number" class="form-input" id="inputFloors" value="6" min="1" max="10" oninput="updateFloors()">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Floor Height (m)</label>
                        <input type="number" class="form-input" id="inputFloorHeight" value="4.0" min="2.5" max="6.0" step="0.5">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Number of Boarding Gates</label>
                        <input type="number" class="form-input" id="inputGates" value="4" min="2" max="8">
                    </div>
                    <button class="btn btn-primary" onclick="regenerateLayout()">üîÑ Regenerate Layout</button>
                </div>

                <div class="panel-section">
                    <h3>üè¢ Floor Selection</h3>
                    <div id="floorButtons" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;">
                        <!-- Floor buttons generated dynamically -->
                    </div>
                    <div style="margin-top: 8px; font-size: 11px; color: #7f8c8d;">
                        Current: <strong id="currentFloorLabel">Ground Floor</strong>
                    </div>
                </div>

                <div class="panel-section">
                    <h3>üèõÔ∏è Atrium (Void Space)</h3>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="hasAtrium" onchange="updateAtrium()"> Enable Central Atrium
                        </label>
                    </div>
                    <div id="atriumControls" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">From Floor</label>
                            <select class="form-select" id="atriumFromFloor">
                                <option value="0">Ground Floor</option>
                                <option value="1">1st Floor</option>
                                <option value="2">2nd Floor</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">To Floor</label>
                            <select class="form-select" id="atriumToFloor">
                                <option value="3">3rd Floor</option>
                                <option value="4">4th Floor</option>
                                <option value="5" selected>5th Floor</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Width (% of building)</label>
                            <input type="range" class="form-input" id="atriumWidth" value="40" min="20" max="60" oninput="updateAtrium()">
                            <span id="atriumWidthValue" style="font-size: 11px; color: #7f8c8d;">40%</span>
                        </div>
                    </div>
                </div>

                <div class="panel-section">
                    <h3>üé® Zones</h3>
                    <div class="form-group">
                        <label class="form-label">Ticketing Area (%)</label>
                        <input type="range" class="form-input" id="inputTicketing" value="20" min="10" max="40" oninput="updateZones()">
                        <span id="ticketingValue" style="font-size: 11px; color: #7f8c8d;">20%</span>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Waiting Area (%)</label>
                        <input type="range" class="form-input" id="inputWaiting" value="30" min="20" max="50" oninput="updateZones()">
                        <span id="waitingValue" style="font-size: 11px; color: #7f8c8d;">30%</span>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Retail Area (%)</label>
                        <input type="range" class="form-input" id="inputRetail" value="15" min="0" max="30" oninput="updateZones()">
                        <span id="retailValue" style="font-size: 11px; color: #7f8c8d;">15%</span>
                    </div>
                </div>

                <div class="panel-section">
                    <h3>üí∞ Estimates</h3>
                    <div class="metric">
                        <span class="metric-label">Floor Area:</span>
                        <span class="metric-value" id="floorArea">2,970 m¬≤</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Total GFA:</span>
                        <span class="metric-value" id="totalArea">17,820 m¬≤</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Building Height:</span>
                        <span class="metric-value" id="buildingHeight">24.0 m</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Est. Capacity:</span>
                        <span class="metric-value" id="capacity">2,000 pax/day</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Est. Cost:</span>
                        <span class="metric-value" id="estCost">$26.7M</span>
                    </div>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="canvas-area">
                <div class="canvas-controls">
                    <h4>üîß Tools</h4>
                    <div>
                        <button class="tool-btn active" id="btnPan" onclick="setTool('pan')">‚úã Pan</button>
                        <button class="tool-btn" id="btnWall" onclick="setTool('wall')">‚ñ¨ Wall</button>
                        <button class="tool-btn" id="btnDoor" onclick="setTool('door')">üö™ Door</button>
                    </div>
                    <hr style="border: none; border-top: 1px solid #dee2e6; margin: 8px 0;">
                    <h4>üîç Zoom</h4>
                    <div>
                        <button class="zoom-btn" onclick="zoomIn()">+</button>
                        <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                        <button class="zoom-btn" onclick="zoomFit()">‚ä°</button>
                    </div>
                    <div style="margin-top: 4px; font-size: 11px; color: #7f8c8d;" id="zoomDisplay">100%</div>
                </div>

                <canvas id="mainCanvas" width="900" height="700"></canvas>
            </div>

            <!-- Right Panel: Export & Actions -->
            <div class="right-panel">
                <div class="panel-section">
                    <h3>üì§ Export Options</h3>
                    <button class="btn btn-success" onclick="exportToJSON()">üíæ Save as JSON</button>
                    <button class="btn btn-warning" onclick="generateDXF()">üìê Generate DXF (All Floors)</button>
                    <button class="btn btn-primary" onclick="generateDatabase()" style="margin-top: 8px;">üóÑÔ∏è Generate Bonsai DB (ARC+STR)</button>
                </div>

                <div class="panel-section">
                    <h3>üì• Load Saved Work</h3>
                    <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="loadFromJSON(event)">
                    <button class="btn btn-primary" onclick="document.getElementById('jsonFileInput').click()">üìÇ Open JSON File</button>
                    <div style="font-size: 10px; color: #7f8c8d; margin-top: 8px;">
                        Load previously saved Terminal 1 design
                    </div>
                </div>

                <div class="panel-section">
                    <h3>üìã Current Layout</h3>
                    <div style="font-size: 11px; color: #7f8c8d;">
                        <p>‚úì <span id="floorCount">6</span> floors defined</p>
                        <p id="atriumStatus">‚Ä¢ Atrium: Not configured</p>
                        <p>‚úì ARC discipline ready</p>
                        <p>‚úì STR discipline ready</p>
                        <p id="wallCount">‚Ä¢ Custom Walls: 0</p>
                        <p id="doorCount">‚Ä¢ Custom Doors: 0</p>
                        <p id="gateCount">‚Ä¢ Boarding Gates: 4</p>
                    </div>
                </div>

                <div class="panel-section" id="zoneLabelPanel" style="display: none;">
                    <h3>üè∑Ô∏è Zone Labels (Upper Floors)</h3>
                    <div style="font-size: 11px; color: #7f8c8d; margin-bottom: 8px;">
                        Ground floor labels are fixed. Change labels for upper floors:
                    </div>
                    <div class="form-group">
                        <label class="form-label">Blue Zone</label>
                        <input type="text" class="form-input" id="labelTicketing" value="SHOPS" maxlength="20" onchange="updateCustomLabels()">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Green Zone</label>
                        <input type="text" class="form-input" id="labelWaiting" value="SHOPS" maxlength="20" onchange="updateCustomLabels()">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Yellow Zone</label>
                        <input type="text" class="form-input" id="labelRetail" value="SHOPS" maxlength="20" onchange="updateCustomLabels()">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Red Zone</label>
                        <input type="text" class="form-input" id="labelBoarding" value="SHOPS" maxlength="20" onchange="updateCustomLabels()">
                    </div>
                </div>

                <div class="panel-section">
                    <h3>‚ÑπÔ∏è Instructions</h3>
                    <div style="font-size: 11px; color: #7f8c8d; line-height: 1.6;">
                        <p><strong>Drag:</strong> Click & drag zone bodies to move</p>
                        <p><strong>Resize:</strong> Click & drag corner/edge handles</p>
                        <p><strong>Labels:</strong> Edit for upper floors (GF fixed)</p>
                        <p><strong>Pan:</strong> Click & drag empty space</p>
                        <p><strong>Scroll:</strong> Zoom in/out</p>
                    </div>
                </div>

                <div class="panel-section">
                    <h3>‚öôÔ∏è Workflow</h3>
                    <div style="font-size: 11px; color: #7f8c8d; line-height: 1.6;">
                        <p>1. Adjust dimensions & zones</p>
                        <p>2. Draw custom walls/doors (optional)</p>
                        <p>3. Export to JSON</p>
                        <p>4. Generate DXF or Database</p>
                        <p>5. Open in Bonsai/AutoCAD</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            <div>Canvas: <span id="cursorPos">(0.0m, 0.0m)</span></div>
            <div>Zoom: <span id="footerZoom">100%</span> | Grid: 1.0m</div>
        </div>
    </div>

    <script>
        // State
        let currentZoom = 1.0;
        let panX = 0, panY = 0;
        let currentTool = 'pan';
        let buildingWidth = 45; // meters
        let buildingDepth = 66; // meters
        let boardingGates = 4;
        let numFloors = 6;
        let floorHeight = 4.0; // meters
        let currentFloor = 0; // 0 = Ground, 1 = 1st, etc.

        // Multi-floor data structure
        let floors = [];

        // Atrium configuration
        let atrium = {
            enabled: false,
            fromFloor: 0,
            toFloor: 5,
            widthPercent: 0.4
        };

        // Drawing elements per floor
        let walls = [];
        let doors = [];
        let zones = {
            ticketing: 0.20,
            waiting: 0.30,
            retail: 0.15
        };

        // Zone positions and sizes (draggable & resizable)
        let zonePositions = {
            ticketing: { x: 0, y: 0 },
            waiting: { x: 0, y: 0 },
            retail: { x: 0, y: 0 },
            boarding: { x: 0, y: 0 }
        };

        // Zone sizes (per floor, user can resize)
        let zoneSizes = {
            ticketing: { width: 0, height: 0 },
            waiting: { width: 0, height: 0 },
            retail: { width: 0, height: 0 },
            boarding: { width: 0, height: 0 }
        };

        // Zone labels (can change per floor)
        let zoneLabels = {
            ticketing: 'TICKETING',
            waiting: 'WAITING',
            retail: 'RETAIL',
            boarding: 'BOARDING GATES'
        };

        let draggedZone = null;
        let zoneDragOffset = { x: 0, y: 0 };
        let resizingZone = null;
        let resizeHandle = null;  // 'se', 'sw', 'ne', 'nw', 'e', 'w', 'n', 's'

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // Initialize floors
        function initializeFloors() {
            floors = [];
            for (let i = 0; i < numFloors; i++) {
                floors.push({
                    level: i,
                    name: i === 0 ? 'Ground Floor' : `${i}${getOrdinalSuffix(i)} Floor`,
                    elevation: i * floorHeight,
                    walls: [],
                    doors: [],
                    slabs: true, // Has floor slab
                    hasAtrium: false
                });
            }
        }

        function getOrdinalSuffix(i) {
            const j = i % 10, k = i % 100;
            if (j === 1 && k !== 11) return 'st';
            if (j === 2 && k !== 12) return 'nd';
            if (j === 3 && k !== 13) return 'rd';
            return 'th';
        }

        // Draw resize handles on zone corners/edges
        function drawResizeHandles(x, y, w, h) {
            const handleSize = 8;
            ctx.fillStyle = '#2c3e50';

            // Corner handles
            ctx.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize); // NW
            ctx.fillRect(x + w - handleSize/2, y - handleSize/2, handleSize, handleSize); // NE
            ctx.fillRect(x - handleSize/2, y + h - handleSize/2, handleSize, handleSize); // SW
            ctx.fillRect(x + w - handleSize/2, y + h - handleSize/2, handleSize, handleSize); // SE

            // Edge handles
            ctx.fillRect(x + w/2 - handleSize/2, y - handleSize/2, handleSize, handleSize); // N
            ctx.fillRect(x + w/2 - handleSize/2, y + h - handleSize/2, handleSize, handleSize); // S
            ctx.fillRect(x - handleSize/2, y + h/2 - handleSize/2, handleSize, handleSize); // W
            ctx.fillRect(x + w - handleSize/2, y + h/2 - handleSize/2, handleSize, handleSize); // E
        }

        // Check if click is on a resize handle
        function getResizeHandle(zone, canvasX, canvasY) {
            const scale = 6;
            const offsetX = (canvas.width - buildingWidth * scale) / 2;
            const offsetY = (canvas.height - buildingDepth * scale) / 2;
            const handleSize = 8;

            const zoneW = zoneSizes[zone].width * scale;
            const zoneH = zoneSizes[zone].height * scale;
            const zoneX = offsetX + (buildingWidth/2 + zonePositions[zone].x - zoneSizes[zone].width/2) * scale;
            const zoneY = offsetY + (buildingDepth/2 + zonePositions[zone].y - zoneSizes[zone].height/2) * scale;

            const worldX = (canvasX - canvas.width/2 - panX) / currentZoom + canvas.width/2;
            const worldY = (canvasY - canvas.height/2 - panY) / currentZoom + canvas.height/2;

            const threshold = handleSize;

            // Check corners first
            if (Math.abs(worldX - zoneX) < threshold && Math.abs(worldY - zoneY) < threshold) return 'nw';
            if (Math.abs(worldX - (zoneX + zoneW)) < threshold && Math.abs(worldY - zoneY) < threshold) return 'ne';
            if (Math.abs(worldX - zoneX) < threshold && Math.abs(worldY - (zoneY + zoneH)) < threshold) return 'sw';
            if (Math.abs(worldX - (zoneX + zoneW)) < threshold && Math.abs(worldY - (zoneY + zoneH)) < threshold) return 'se';

            // Check edges
            if (Math.abs(worldX - (zoneX + zoneW/2)) < threshold && Math.abs(worldY - zoneY) < threshold) return 'n';
            if (Math.abs(worldX - (zoneX + zoneW/2)) < threshold && Math.abs(worldY - (zoneY + zoneH)) < threshold) return 's';
            if (Math.abs(worldX - zoneX) < threshold && Math.abs(worldY - (zoneY + zoneH/2)) < threshold) return 'w';
            if (Math.abs(worldX - (zoneX + zoneW)) < threshold && Math.abs(worldY - (zoneY + zoneH/2)) < threshold) return 'e';

            return null;
        }

        // Initialize
        initializeFloors();
        updateFloorButtons();
        updateZoneLabels();
        updateEstimates();
        drawLayout();

        // Tool selection
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn' + tool.charAt(0).toUpperCase() + tool.slice(1)).classList.add('active');

            if (tool === 'pan') canvas.style.cursor = 'grab';
            else if (tool === 'wall') canvas.style.cursor = 'crosshair';
            else if (tool === 'door') canvas.style.cursor = 'pointer';
        }

        // Regenerate layout
        function regenerateLayout() {
            buildingWidth = parseInt(document.getElementById('inputWidth').value);
            buildingDepth = parseInt(document.getElementById('inputDepth').value);
            boardingGates = parseInt(document.getElementById('inputGates').value);
            floorHeight = parseFloat(document.getElementById('inputFloorHeight').value);
            updateFloors();
            updateEstimates();
            drawLayout();
        }

        // Update floors
        function updateFloors() {
            const newNumFloors = parseInt(document.getElementById('inputFloors').value);
            if (newNumFloors !== numFloors) {
                numFloors = newNumFloors;
                initializeFloors();
                updateFloorButtons();
                currentFloor = 0;
                updateAtrium();
            }
            updateEstimates();
        }

        // Custom labels for upper floors
        let customLabels = {
            ticketing: 'SHOPS',
            waiting: 'SHOPS',
            retail: 'SHOPS',
            boarding: 'SHOPS'
        };

        // Update zone labels based on floor
        function updateZoneLabels() {
            if (currentFloor === 0) {
                // Ground floor - fixed labels
                zoneLabels.ticketing = 'TICKETING';
                zoneLabels.waiting = 'WAITING';
                zoneLabels.retail = 'RETAIL';
                zoneLabels.boarding = 'BOARDING GATES';
                // Hide label editor
                document.getElementById('zoneLabelPanel').style.display = 'none';
            } else {
                // Upper floors - use custom labels
                zoneLabels.ticketing = customLabels.ticketing;
                zoneLabels.waiting = customLabels.waiting;
                zoneLabels.retail = customLabels.retail;
                zoneLabels.boarding = customLabels.boarding;
                // Show label editor
                document.getElementById('zoneLabelPanel').style.display = 'block';
            }
        }

        // Update custom labels from input
        function updateCustomLabels() {
            customLabels.ticketing = document.getElementById('labelTicketing').value.toUpperCase();
            customLabels.waiting = document.getElementById('labelWaiting').value.toUpperCase();
            customLabels.retail = document.getElementById('labelRetail').value.toUpperCase();
            customLabels.boarding = document.getElementById('labelBoarding').value.toUpperCase();
            updateZoneLabels();
            drawLayout();
        }

        // Update floor buttons
        function updateFloorButtons() {
            const container = document.getElementById('floorButtons');
            container.innerHTML = '';

            for (let i = 0; i < numFloors; i++) {
                const btn = document.createElement('button');
                btn.className = 'tool-btn';
                btn.textContent = i === 0 ? 'GF' : `${i}F`;
                btn.onclick = () => switchFloor(i);
                if (i === currentFloor) btn.classList.add('active');
                container.appendChild(btn);
            }

            document.getElementById('floorCount').textContent = numFloors;
        }

        // Switch floor
        function switchFloor(floorNum) {
            currentFloor = floorNum;
            walls = floors[currentFloor].walls;
            doors = floors[currentFloor].doors;
            updateFloorButtons();
            updateZoneLabels();  // Update labels based on floor
            document.getElementById('currentFloorLabel').textContent = floors[currentFloor].name;
            drawLayout();
        }

        // Update atrium
        function updateAtrium() {
            atrium.enabled = document.getElementById('hasAtrium').checked;
            document.getElementById('atriumControls').style.display = atrium.enabled ? 'block' : 'none';

            if (atrium.enabled) {
                atrium.fromFloor = parseInt(document.getElementById('atriumFromFloor').value);
                atrium.toFloor = parseInt(document.getElementById('atriumToFloor').value);
                atrium.widthPercent = parseInt(document.getElementById('atriumWidth').value) / 100;
                document.getElementById('atriumWidthValue').textContent = Math.round(atrium.widthPercent * 100) + '%';

                // Mark floors with atrium
                floors.forEach((floor, i) => {
                    floor.hasAtrium = i >= atrium.fromFloor && i <= atrium.toFloor;
                });

                const fromName = floors[atrium.fromFloor].name;
                const toName = floors[atrium.toFloor].name;
                document.getElementById('atriumStatus').textContent =
                    `‚Ä¢ Atrium: ${fromName} to ${toName}`;
            } else {
                floors.forEach(floor => floor.hasAtrium = false);
                document.getElementById('atriumStatus').textContent = '‚Ä¢ Atrium: Not configured';
            }

            drawLayout();
        }

        // Update zones
        function updateZones() {
            zones.ticketing = parseInt(document.getElementById('inputTicketing').value) / 100;
            zones.waiting = parseInt(document.getElementById('inputWaiting').value) / 100;
            zones.retail = parseInt(document.getElementById('inputRetail').value) / 100;

            document.getElementById('ticketingValue').textContent = Math.round(zones.ticketing * 100) + '%';
            document.getElementById('waitingValue').textContent = Math.round(zones.waiting * 100) + '%';
            document.getElementById('retailValue').textContent = Math.round(zones.retail * 100) + '%';

            drawLayout();
        }

        // Update estimates
        function updateEstimates() {
            const floorArea = buildingWidth * buildingDepth;
            const totalGFA = floorArea * numFloors;
            const height = numFloors * floorHeight;

            document.getElementById('floorArea').textContent = floorArea.toLocaleString() + ' m¬≤';
            document.getElementById('totalArea').textContent = totalGFA.toLocaleString() + ' m¬≤';
            document.getElementById('buildingHeight').textContent = height.toFixed(1) + ' m';
            document.getElementById('capacity').textContent = Math.round(floorArea * 0.67).toLocaleString() + ' pax/day';
            document.getElementById('estCost').textContent = '$' + (totalGFA * 1.5 / 1000).toFixed(1) + 'M';
            document.getElementById('gateCount').textContent = '‚Ä¢ Boarding Gates: ' + boardingGates;
        }

        // Draw layout
        function drawLayout() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // Apply zoom and pan
            ctx.translate(canvas.width/2 + panX, canvas.height/2 + panY);
            ctx.scale(currentZoom, currentZoom);
            ctx.translate(-canvas.width/2, -canvas.height/2);

            const scale = 6; // pixels per meter
            const offsetX = (canvas.width - buildingWidth * scale) / 2;
            const offsetY = (canvas.height - buildingDepth * scale) / 2;

            // Grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= canvas.width; x += scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Building outline
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 4;
            ctx.strokeRect(offsetX, offsetY, buildingWidth * scale, buildingDepth * scale);

            // Zones (draggable)
            const ticketingWidth = buildingWidth * zones.ticketing;
            const waitingWidth = buildingWidth * zones.waiting;
            const retailWidth = buildingWidth * zones.retail;
            const zoneHeight = buildingDepth * 0.4;  // Zone height

            // Initialize default positions and sizes if not set
            if (zonePositions.ticketing.x === 0 && zonePositions.ticketing.y === 0) {
                zonePositions.ticketing = { x: -buildingWidth/2 + ticketingWidth/2, y: -buildingDepth/4 };
                zonePositions.waiting = { x: -buildingWidth/2 + ticketingWidth + waitingWidth/2, y: -buildingDepth/4 };
                zonePositions.retail = { x: -buildingWidth/2 + ticketingWidth + waitingWidth + retailWidth/2, y: -buildingDepth/4 };
                zonePositions.boarding = { x: 0, y: buildingDepth/4 };

                // Initialize sizes
                zoneSizes.ticketing = { width: ticketingWidth, height: zoneHeight };
                zoneSizes.waiting = { width: waitingWidth, height: zoneHeight };
                zoneSizes.retail = { width: retailWidth, height: zoneHeight };
                zoneSizes.boarding = { width: buildingWidth * 0.8, height: buildingDepth * 0.3 };
            }

            // Ticketing zone (user-resizable)
            const ticketW = zoneSizes.ticketing.width * scale;
            const ticketH = zoneSizes.ticketing.height * scale;
            const ticketX = offsetX + (buildingWidth/2 + zonePositions.ticketing.x - zoneSizes.ticketing.width/2) * scale;
            const ticketY = offsetY + (buildingDepth/2 + zonePositions.ticketing.y - zoneSizes.ticketing.height/2) * scale;

            ctx.fillStyle = 'rgba(52, 152, 219, 0.15)';
            ctx.fillRect(ticketX, ticketY, ticketW, ticketH);
            ctx.strokeStyle = (draggedZone === 'ticketing' || resizingZone === 'ticketing') ? '#2980b9' : '#3498db';
            ctx.lineWidth = (draggedZone === 'ticketing' || resizingZone === 'ticketing') ? 4 : 2;
            ctx.strokeRect(ticketX, ticketY, ticketW, ticketH);

            // Resize handles
            if (resizingZone === 'ticketing' || draggedZone === 'ticketing') {
                drawResizeHandles(ticketX, ticketY, ticketW, ticketH);
            }

            ctx.fillStyle = '#3498db';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(zoneLabels.ticketing, ticketX + ticketW/2, ticketY + ticketH/2);

            // Waiting zone (user-resizable)
            const waitW = zoneSizes.waiting.width * scale;
            const waitH = zoneSizes.waiting.height * scale;
            const waitX = offsetX + (buildingWidth/2 + zonePositions.waiting.x - zoneSizes.waiting.width/2) * scale;
            const waitY = offsetY + (buildingDepth/2 + zonePositions.waiting.y - zoneSizes.waiting.height/2) * scale;

            ctx.fillStyle = 'rgba(46, 204, 113, 0.15)';
            ctx.fillRect(waitX, waitY, waitW, waitH);
            ctx.strokeStyle = (draggedZone === 'waiting' || resizingZone === 'waiting') ? '#27ae60' : '#2ecc71';
            ctx.lineWidth = (draggedZone === 'waiting' || resizingZone === 'waiting') ? 4 : 2;
            ctx.strokeRect(waitX, waitY, waitW, waitH);

            if (resizingZone === 'waiting' || draggedZone === 'waiting') {
                drawResizeHandles(waitX, waitY, waitW, waitH);
            }

            ctx.fillStyle = '#2ecc71';
            ctx.fillText(zoneLabels.waiting, waitX + waitW/2, waitY + waitH/2);

            // Retail zone (user-resizable)
            if (zones.retail > 0 || zoneSizes.retail.width > 0) {
                const retailW = zoneSizes.retail.width * scale;
                const retailH = zoneSizes.retail.height * scale;
                const retailX = offsetX + (buildingWidth/2 + zonePositions.retail.x - zoneSizes.retail.width/2) * scale;
                const retailY = offsetY + (buildingDepth/2 + zonePositions.retail.y - zoneSizes.retail.height/2) * scale;

                ctx.fillStyle = 'rgba(241, 196, 15, 0.15)';
                ctx.fillRect(retailX, retailY, retailW, retailH);
                ctx.strokeStyle = (draggedZone === 'retail' || resizingZone === 'retail') ? '#f39c12' : '#f1c40f';
                ctx.lineWidth = (draggedZone === 'retail' || resizingZone === 'retail') ? 4 : 2;
                ctx.strokeRect(retailX, retailY, retailW, retailH);

                if (resizingZone === 'retail' || draggedZone === 'retail') {
                    drawResizeHandles(retailX, retailY, retailW, retailH);
                }

                ctx.fillStyle = '#f1c40f';
                ctx.fillText(zoneLabels.retail, retailX + retailW/2, retailY + retailH/2);
            }

            // Boarding gates zone (user-resizable)
            const boardW = zoneSizes.boarding.width * scale;
            const boardH = zoneSizes.boarding.height * scale;
            const boardX = offsetX + (buildingWidth/2 + zonePositions.boarding.x - zoneSizes.boarding.width/2) * scale;
            const boardY = offsetY + (buildingDepth/2 + zonePositions.boarding.y - zoneSizes.boarding.height/2) * scale;

            ctx.fillStyle = 'rgba(231, 76, 60, 0.15)';
            ctx.fillRect(boardX, boardY, boardW, boardH);
            ctx.strokeStyle = (draggedZone === 'boarding' || resizingZone === 'boarding') ? '#c0392b' : '#e74c3c';
            ctx.lineWidth = (draggedZone === 'boarding' || resizingZone === 'boarding') ? 4 : 2;
            ctx.strokeRect(boardX, boardY, boardW, boardH);

            if (resizingZone === 'boarding' || draggedZone === 'boarding') {
                drawResizeHandles(boardX, boardY, boardW, boardH);
            }

            ctx.fillStyle = '#e74c3c';
            ctx.fillText(zoneLabels.boarding, boardX + boardW/2, boardY + boardH/2);

            // Atrium (if enabled on this floor)
            if (floors[currentFloor].hasAtrium) {
                const atriumWidth = buildingWidth * atrium.widthPercent;
                const atriumX = offsetX + (buildingWidth - atriumWidth) * scale / 2;
                const atriumY = offsetY + (buildingDepth * 0.3) * scale;
                const atriumW = atriumWidth * scale;
                const atriumH = (buildingDepth * 0.4) * scale;

                // Void space indication
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(atriumX, atriumY, atriumW, atriumH);
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(atriumX, atriumY, atriumW, atriumH);
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = '#95a5a6';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('ATRIUM', atriumX + atriumW/2, atriumY + atriumH/2 - 10);
                ctx.font = '11px Arial';
                ctx.fillText('(Void - Open to Below)', atriumX + atriumW/2, atriumY + atriumH/2 + 10);
            }

            // Boarding gate symbols
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            for (let i = 0; i < boardingGates; i++) {
                const gateX = offsetX + (buildingWidth / (boardingGates + 1) * (i + 1)) * scale;
                const gateY = offsetY + buildingDepth * scale;
                ctx.beginPath();
                ctx.arc(gateX, gateY, 12, Math.PI, 0);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Custom walls
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 6;
            walls.forEach(wall => {
                ctx.beginPath();
                ctx.moveTo(wall.x1, wall.y1);
                ctx.lineTo(wall.x2, wall.y2);
                ctx.stroke();
            });

            // Custom doors
            ctx.strokeStyle = '#e74c3c';
            ctx.fillStyle = '#e74c3c';
            doors.forEach(door => {
                ctx.beginPath();
                ctx.arc(door.x, door.y, 8, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        // Zoom functions
        function zoomIn() {
            currentZoom *= 1.2;
            updateZoomDisplay();
            drawLayout();
        }

        function zoomOut() {
            currentZoom /= 1.2;
            updateZoomDisplay();
            drawLayout();
        }

        function zoomFit() {
            currentZoom = 1.0;
            panX = 0;
            panY = 0;
            updateZoomDisplay();
            drawLayout();
        }

        function updateZoomDisplay() {
            const zoomPercent = Math.round(currentZoom * 100) + '%';
            document.getElementById('zoomDisplay').textContent = zoomPercent;
            document.getElementById('footerZoom').textContent = zoomPercent;
        }

        // Mouse interactions
        let isPanning = false;
        let lastMouseX = 0, lastMouseY = 0;
        let wallStart = null;

        // Helper function to check if click is inside a zone
        function getZoneAtPoint(canvasX, canvasY) {
            const scale = 6;
            const offsetX = (canvas.width - buildingWidth * scale) / 2;
            const offsetY = (canvas.height - buildingDepth * scale) / 2;

            const ticketingWidth = buildingWidth * zones.ticketing;
            const waitingWidth = buildingWidth * zones.waiting;
            const retailWidth = buildingWidth * zones.retail;
            const zoneHeight = buildingDepth * 0.4;

            // Convert canvas coords to world coords (accounting for pan/zoom)
            const worldX = (canvasX - canvas.width/2 - panX) / currentZoom + canvas.width/2;
            const worldY = (canvasY - canvas.height/2 - panY) / currentZoom + canvas.height/2;

            // Check ticketing
            const ticketX = offsetX + (buildingWidth/2 + zonePositions.ticketing.x - ticketingWidth/2) * scale;
            const ticketY = offsetY + (buildingDepth/2 + zonePositions.ticketing.y - zoneHeight/2) * scale;
            if (worldX >= ticketX && worldX <= ticketX + ticketingWidth * scale &&
                worldY >= ticketY && worldY <= ticketY + zoneHeight * scale) {
                return 'ticketing';
            }

            // Check waiting
            const waitX = offsetX + (buildingWidth/2 + zonePositions.waiting.x - waitingWidth/2) * scale;
            const waitY = offsetY + (buildingDepth/2 + zonePositions.waiting.y - zoneHeight/2) * scale;
            if (worldX >= waitX && worldX <= waitX + waitingWidth * scale &&
                worldY >= waitY && worldY <= waitY + zoneHeight * scale) {
                return 'waiting';
            }

            // Check retail
            if (zones.retail > 0) {
                const retailX = offsetX + (buildingWidth/2 + zonePositions.retail.x - retailWidth/2) * scale;
                const retailY = offsetY + (buildingDepth/2 + zonePositions.retail.y - zoneHeight/2) * scale;
                if (worldX >= retailX && worldX <= retailX + retailWidth * scale &&
                    worldY >= retailY && worldY <= retailY + zoneHeight * scale) {
                    return 'retail';
                }
            }

            // Check boarding
            const boardingWidth = buildingWidth * 0.8;
            const boardingDepth = buildingDepth * 0.3;
            const boardX = offsetX + (buildingWidth/2 + zonePositions.boarding.x - boardingWidth/2) * scale;
            const boardY = offsetY + (buildingDepth/2 + zonePositions.boarding.y - boardingDepth/2) * scale;
            if (worldX >= boardX && worldX <= boardX + boardingWidth * scale &&
                worldY >= boardY && worldY <= boardY + boardingDepth * scale) {
                return 'boarding';
            }

            return null;
        }

        canvas.addEventListener('mousedown', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on a resize handle first (highest priority)
            const zones = ['ticketing', 'waiting', 'retail', 'boarding'];
            for (let zone of zones) {
                const handle = getResizeHandle(zone, x, y);
                if (handle) {
                    resizingZone = zone;
                    resizeHandle = handle;
                    zoneDragOffset.x = x;
                    zoneDragOffset.y = y;
                    canvas.style.cursor = getResizeCursor(handle);
                    drawLayout();
                    return;
                }
            }

            // Check if clicking on a zone body
            const zone = getZoneAtPoint(x, y);
            if (zone) {
                draggedZone = zone;
                zoneDragOffset.x = x;
                zoneDragOffset.y = y;
                canvas.style.cursor = 'move';
                drawLayout();
                return;
            }

            if (currentTool === 'pan') {
                isPanning = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            } else if (currentTool === 'wall') {
                if (!wallStart) {
                    wallStart = {x, y};
                } else {
                    const wall = {x1: wallStart.x, y1: wallStart.y, x2: x, y2: y};
                    walls.push(wall);
                    floors[currentFloor].walls.push(wall);
                    wallStart = null;
                    document.getElementById('wallCount').textContent = '‚Ä¢ Custom Walls: ' + walls.length;
                    drawLayout();
                }
            } else if (currentTool === 'door') {
                const door = {x, y};
                doors.push(door);
                floors[currentFloor].doors.push(door);
                document.getElementById('doorCount').textContent = '‚Ä¢ Custom Doors: ' + doors.length;
                drawLayout();
            }
        });

        // Get resize cursor based on handle
        function getResizeCursor(handle) {
            const cursors = {
                'nw': 'nw-resize', 'ne': 'ne-resize',
                'sw': 'sw-resize', 'se': 'se-resize',
                'n': 'n-resize', 's': 's-resize',
                'w': 'w-resize', 'e': 'e-resize'
            };
            return cursors[handle] || 'default';
        }

        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            const x = ((canvasX - canvas.width/2) / 6).toFixed(1);
            const y = ((canvasY - canvas.height/2) / 6).toFixed(1);
            document.getElementById('cursorPos').textContent = `(${x}m, ${y}m)`;

            if (resizingZone) {
                // Resizing a zone
                const dx = (canvasX - zoneDragOffset.x) / 6;  // Convert pixels to meters
                const dy = (canvasY - zoneDragOffset.y) / 6;

                const zone = resizingZone;
                const handle = resizeHandle;

                // Resize based on handle direction
                if (handle.includes('e')) {
                    zoneSizes[zone].width += dx;
                    zonePositions[zone].x += dx / 2;  // Keep centered
                }
                if (handle.includes('w')) {
                    zoneSizes[zone].width -= dx;
                    zonePositions[zone].x += dx / 2;
                }
                if (handle.includes('s')) {
                    zoneSizes[zone].height += dy;
                    zonePositions[zone].y += dy / 2;
                }
                if (handle.includes('n')) {
                    zoneSizes[zone].height -= dy;
                    zonePositions[zone].y += dy / 2;
                }

                // Enforce minimum size
                if (zoneSizes[zone].width < 3) zoneSizes[zone].width = 3;
                if (zoneSizes[zone].height < 3) zoneSizes[zone].height = 3;

                zoneDragOffset.x = canvasX;
                zoneDragOffset.y = canvasY;

                drawLayout();
            } else if (draggedZone) {
                // Dragging a zone
                const dx = (canvasX - zoneDragOffset.x) / 6;
                const dy = (canvasY - zoneDragOffset.y) / 6;

                zonePositions[draggedZone].x += dx;
                zonePositions[draggedZone].y += dy;

                zoneDragOffset.x = canvasX;
                zoneDragOffset.y = canvasY;

                drawLayout();
            } else if (isPanning) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                panX += dx;
                panY += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                drawLayout();
            }
        });

        canvas.addEventListener('mouseup', function() {
            if (resizingZone) {
                resizingZone = null;
                resizeHandle = null;
                canvas.style.cursor = 'default';
                drawLayout();
            }
            if (draggedZone) {
                draggedZone = null;
                canvas.style.cursor = 'default';
                drawLayout();
            }
            isPanning = false;
            if (currentTool === 'pan') canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            if (e.deltaY < 0) zoomIn();
            else zoomOut();
        });

        // Export functions
        function exportToJSON() {
            // Generate structural grid (6m spacing typical for terminals)
            const gridSpacing = 6.0;
            const gridColumns = Math.floor(buildingWidth / gridSpacing) + 1;
            const gridRows = Math.floor(buildingDepth / gridSpacing) + 1;

            const design = {
                metadata: {
                    project: "Ferry Terminal Complex - Terminal 1",
                    date: new Date().toISOString().split('T')[0],
                    units: "meters",
                    version: "1.0"
                },
                building: {
                    width: buildingWidth,
                    depth: buildingDepth,
                    numFloors: numFloors,
                    floorHeight: floorHeight,
                    totalHeight: numFloors * floorHeight,
                    gates: boardingGates
                },
                disciplines: ["ARC", "STR"],
                atrium: atrium,
                zones: zones,
                zonePositions: zonePositions,
                zoneSizes: zoneSizes,
                customLabels: customLabels,

                // ARC discipline data
                architecture: {
                    floors: floors.map(floor => ({
                        level: floor.level,
                        name: floor.name,
                        elevation: floor.elevation,
                        hasAtrium: floor.hasAtrium,
                        elements: {
                            walls: floor.walls,
                            doors: floor.doors,
                            zones: currentFloor === 0 ? {
                                ticketing: {
                                    width: buildingWidth * zones.ticketing,
                                    depth: buildingDepth * 0.5
                                },
                                waiting: {
                                    width: buildingWidth * zones.waiting,
                                    depth: buildingDepth * 0.5
                                },
                                retail: {
                                    width: buildingWidth * zones.retail,
                                    depth: buildingDepth * 0.5
                                },
                                boarding: {
                                    width: buildingWidth,
                                    depth: buildingDepth * 0.5,
                                    gates: boardingGates
                                }
                            } : null
                        }
                    }))
                },

                // STR discipline data
                structure: {
                    gridSpacing: gridSpacing,
                    columns: {
                        count: gridColumns * gridRows * numFloors,
                        gridX: gridColumns,
                        gridY: gridRows,
                        size: "400x400mm", // Typical for terminals
                        material: "Reinforced Concrete C30"
                    },
                    beams: {
                        horizontal: (gridColumns - 1) * gridRows * numFloors,
                        longitudinal: gridColumns * (gridRows - 1) * numFloors,
                        size: "300x600mm",
                        material: "Reinforced Concrete C30"
                    },
                    slabs: {
                        floors: floors.map(floor => ({
                            level: floor.level,
                            hasSlab: floor.slabs && !floor.hasAtrium,
                            thickness: 150, // mm
                            material: "Reinforced Concrete Slab C30"
                        }))
                    },
                    foundation: {
                        type: "Pile Cap with Bored Piles",
                        depth: -3.0, // meters below ground
                        pileDepth: -15.0
                    }
                },

                // For Bonsai database generation
                bonsai: {
                    coordinateSystem: "Local (0,0,0 at building corner)",
                    disciplines: {
                        ARC: {
                            color: [0.8, 0.8, 0.9],
                            elements: floors.reduce((sum, f) => sum + f.walls.length + f.doors.length + 1, 0)
                        },
                        STR: {
                            color: [0.9, 0.7, 0.5],
                            elements: gridColumns * gridRows * numFloors +
                                     (gridColumns - 1) * gridRows * numFloors +
                                     gridColumns * (gridRows - 1) * numFloors +
                                     floors.filter(f => !f.hasAtrium).length
                        }
                    }
                }
            };

            const json = JSON.stringify(design, null, 2);
            const blob = new Blob([json], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'terminal1_complete_design.json';
            a.click();

            alert('‚úì Terminal 1 design saved!\n\n' +
                  'Ready for Bonsai DB export:\n' +
                  '‚Ä¢ ' + numFloors + ' floors\n' +
                  '‚Ä¢ ' + (atrium.enabled ? 'Atrium configured' : 'No atrium') + '\n' +
                  '‚Ä¢ ARC discipline ready\n' +
                  '‚Ä¢ STR discipline ready\n' +
                  '‚Ä¢ ' + (gridColumns * gridRows) + ' columns per floor\n\n' +
                  'Next: Run generate_arc_str_database.py');
        }

        function generateDXF() {
            alert('üî® DXF Generation\n\nTo generate DXF:\n1. Export to JSON first\n2. Run: python MiniBonsai/Scripts/generate_clean_dxf.py ferry_terminal_design.json\n3. Output: ferry_terminal.dxf');
        }

        function generateDatabase() {
            const gridSpacing = 6.0;
            const gridColumns = Math.floor(buildingWidth / gridSpacing) + 1;
            const gridRows = Math.floor(buildingDepth / gridSpacing) + 1;
            const totalColumns = gridColumns * gridRows * numFloors;
            const totalBeams = ((gridColumns - 1) * gridRows + gridColumns * (gridRows - 1)) * numFloors;
            const totalSlabs = floors.filter(f => !f.hasAtrium).length;

            alert('üóÑÔ∏è Bonsai Database Generation\n\n' +
                  '‚ïê‚ïê‚ïê Building Stats ‚ïê‚ïê‚ïê\n' +
                  '‚Ä¢ Floors: ' + numFloors + '\n' +
                  '‚Ä¢ Height: ' + (numFloors * floorHeight).toFixed(1) + 'm\n' +
                  '‚Ä¢ Footprint: ' + buildingWidth + 'm √ó ' + buildingDepth + 'm\n\n' +
                  '‚ïê‚ïê‚ïê ARC Elements ‚ïê‚ïê‚ïê\n' +
                  '‚Ä¢ Floor slabs: ' + totalSlabs + '\n' +
                  '‚Ä¢ Walls: ' + floors.reduce((sum, f) => sum + f.walls.length, 0) + ' custom\n' +
                  '‚Ä¢ Doors: ' + floors.reduce((sum, f) => sum + f.doors.length, 0) + ' custom\n' +
                  (atrium.enabled ? '‚Ä¢ Atrium void configured\n' : '') + '\n' +
                  '‚ïê‚ïê‚ïê STR Elements ‚ïê‚ïê‚ïê\n' +
                  '‚Ä¢ Grid: ' + gridColumns + '√ó' + gridRows + ' @ ' + gridSpacing + 'm\n' +
                  '‚Ä¢ Columns: ' + totalColumns + '\n' +
                  '‚Ä¢ Beams: ' + totalBeams + '\n' +
                  '‚Ä¢ Slabs: ' + totalSlabs + ' (excluding atrium)\n\n' +
                  '‚ïê‚ïê‚ïê Export Steps ‚ïê‚ïê‚ïê\n' +
                  '1. Export to JSON first\n' +
                  '2. Run: python Scripts/generate_arc_str_database.py terminal1_complete_design.json\n' +
                  '3. Output: Terminal1_Complete.db\n' +
                  '4. Open in Bonsai: ~/blender-4.2.14/blender\n' +
                  '5. Load database in Bonsai viewport\n' +
                  '6. Export to IFC if needed');
        }

        function loadFromJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const design = JSON.parse(e.target.result);

                    // Restore building parameters
                    buildingWidth = design.building.width;
                    buildingDepth = design.building.depth;
                    numFloors = design.building.numFloors;
                    floorHeight = design.building.floorHeight;
                    boardingGates = design.building.gates;

                    // Update UI inputs
                    document.getElementById('inputWidth').value = buildingWidth;
                    document.getElementById('inputDepth').value = buildingDepth;
                    document.getElementById('inputFloors').value = numFloors;
                    document.getElementById('inputFloorHeight').value = floorHeight;
                    document.getElementById('inputGates').value = boardingGates;

                    // Restore zones
                    if (design.zones) {
                        zones = design.zones;
                        document.getElementById('inputTicketing').value = Math.round(zones.ticketing * 100);
                        document.getElementById('inputWaiting').value = Math.round(zones.waiting * 100);
                        document.getElementById('inputRetail').value = Math.round(zones.retail * 100);
                        updateZones();
                    }

                    // Restore zone positions and sizes
                    if (design.zonePositions) {
                        zonePositions = design.zonePositions;
                    }
                    if (design.zoneSizes) {
                        zoneSizes = design.zoneSizes;
                    }
                    if (design.customLabels) {
                        customLabels = design.customLabels;
                        // Update input fields
                        document.getElementById('labelTicketing').value = customLabels.ticketing;
                        document.getElementById('labelWaiting').value = customLabels.waiting;
                        document.getElementById('labelRetail').value = customLabels.retail;
                        document.getElementById('labelBoarding').value = customLabels.boarding;
                    }

                    // Restore atrium
                    if (design.atrium) {
                        atrium = design.atrium;
                        document.getElementById('hasAtrium').checked = atrium.enabled;
                        if (atrium.enabled) {
                            document.getElementById('atriumFromFloor').value = atrium.fromFloor;
                            document.getElementById('atriumToFloor').value = atrium.toFloor;
                            document.getElementById('atriumWidth').value = Math.round(atrium.widthPercent * 100);
                        }
                        updateAtrium();
                    }

                    // Restore floors with custom walls/doors
                    if (design.architecture && design.architecture.floors) {
                        initializeFloors(); // Reset floors first
                        design.architecture.floors.forEach((floorData, i) => {
                            if (i < floors.length) {
                                floors[i].walls = floorData.elements.walls || [];
                                floors[i].doors = floorData.elements.doors || [];
                                floors[i].hasAtrium = floorData.hasAtrium || false;
                            }
                        });
                    }

                    // Restore current floor view
                    currentFloor = 0;
                    walls = floors[0].walls;
                    doors = floors[0].doors;

                    // Update UI
                    updateFloorButtons();
                    updateEstimates();

                    // Update status counters
                    const totalWalls = floors.reduce((sum, f) => sum + f.walls.length, 0);
                    const totalDoors = floors.reduce((sum, f) => sum + f.doors.length, 0);
                    document.getElementById('wallCount').textContent = '‚Ä¢ Custom Walls: ' + totalWalls;
                    document.getElementById('doorCount').textContent = '‚Ä¢ Custom Doors: ' + totalDoors;

                    // Redraw
                    drawLayout();

                    alert('‚úì Design loaded successfully!\n\n' +
                          'Building: ' + buildingWidth + 'm √ó ' + buildingDepth + 'm\n' +
                          'Floors: ' + numFloors + '\n' +
                          'Custom walls: ' + totalWalls + '\n' +
                          'Custom doors: ' + totalDoors + '\n' +
                          (atrium.enabled ? 'Atrium: Configured' : 'Atrium: Not configured'));

                } catch (error) {
                    alert('Error loading JSON file:\n' + error.message);
                    console.error('JSON load error:', error);
                }
            };

            reader.readAsText(file);
        }
    </script>
</body>
</html>
